## 데이터베이스 인덱스

인덱스란 데이터베이스에 적용하는 **정렬 기준**을 의미한다. 인덱스를 적용하면 WHERE 절을 이용한 **검색 성능 향상**을 기대할 수 있다.

### 특징

1. 인덱스는 항상 **최신의 정렬 상태 유지**
2. 인덱스도 하나의 데이터 베이스 객체
3. 데이터베이스 크기의 **약 10% 정도의 저장공간** 필요

### 인덱스 알고리즘

- 페이지

  페이지란 데이터가 저장되는 단위이며 MySQL에 경우 16kbyte 이다. Full Table Scan 을 사용하면 순차적으로 접근하고, 접근 비용이 적게 든다. 주로 인덱스가 없거나, 있더라도 처리 범위가 넓은 경우, 크기가 작은 테이블에 접근할 때 사용한다.

- B-tree

  B-Tree 란 Binary Search Tree 의 단점을 극복하기 위해 만들어진 방식으로 Balanced-Tree 라고도 한다. 특징으론 트리의 높이가 같고 자식 노드를 2개 이상 가질 수 있다. **기본적인 데이터베이스 인덱스 구조**다.


### 인덱스 종류

- 클러스터링 인덱스

  실제 무리와 같은 무리의 인덱스 ex) primary key 사용

  기본적으로 B-Tree 구조

- 논-클러스터링 인덱스

  실제 데이터와 다른 무리의 인덱스 ex) unique 제약 조건


### 인덱스 적용 기준

- 카디널리티가 높다 → 중복 수치가 낮다 ex) 이메일주소
- WHERE, JOIN, ORDER BY 절이 자주 사용 되는 컬럼
- CUD 작용이 잘 발생하지 않는 컬럼
- 규모가 있는 테이블

### 주의사항

1. 잘 활용되지 않는 인덱스는 과감히 제거하자
    - WHERE 절에 사용 되더라도 자주 사용해야 가치가 있다.
    - 불필요한 인덱싱은 성능 저하가를 일으킨다.
2. 데이터 중복도가 높은 인덱스는 효과가 적다
3. 자주 사용되더라도 INSERT / UPDATE / DELETE 가 자주 일어나는지 고려해야 한다.
    - 일반적인 웹 서비스와 같은 온라인 트랜잭션 환경에서 쓰기와 읽기 비율은 2:8~1:9 정도다.
    - 조금 느린 쓰기를 감수하고 빠른 읽기를 선택하는 것도 하나의 방법이다.


---

## 데이터베이스 Lock

### 동시성 제어

만약 재고가 1개 남은 상품을 2명이 거의 동시 주문하게 된다면 어떻게 될까? 모두 구매 완료되는 문제가 생길 수 있다. 트랜잭션들이 동시에 수행될 때 일관성을 해치지 않도록 **데이터 접근을 제어 하는 기능**이 필요하다.

### 어떻게?

여기서 **데이터베이스 락** 이라는 개념이 등장한다. 락에는 낙관적 락과 비관적 락이 있다. **낙관적 락은 데이터 경합이 발생하지 않을 것이라고 예상**하고, 데이터 접근을 제한하지 않는 방식이다. **비관적 락은 동시에 수정할 가능성이 높다고 예상**하고, 접근 자체를 제한해서 대기하게 한다.

### 비관적 락의 종류

- 공용(shared) Lock

  Read 연산 가능, Write 연산 불가능

  여러 트랜잭션에서 접근 가능

- 배타(Exclusive) Lock

  현재 실행중인 트랜잭션이 독점권을 가진다.


### 문제점 - Blocking

- 락들의 경합이 발생하여 작업이 멈춰선 상태
- 특정 데이터에 베타락이 걸려 있다면 다른 요청들은 전부 대기해야하기 때문에 발생
- 트랜잭션을 commit / rollback 해줘야 함

### 해결법

1. 트랜잭션을 짧게 정의
2. 같은 데이터를 동시 갱신하지 않게 설계
3. timeout을 설정해서 시간 조절

### 문제점 - DeadLock(교착상태)
![](https://velog.velcdn.com/images/taaaaate/post/aae3bf95-b985-4213-8404-102fadf21083/image.png)
### 해결법

1. 트랜잭션 진행방향을 같은 방향으로 처리
2. 트랜잭션 처리속도 최적화
3. timeout을 설정해서 시간 조절